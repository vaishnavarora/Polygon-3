# Polygon-3

## Quick Start
Compile the Multiplier2() circuit and verify it against a smart contract verifier

```
pragma circom 2.0.0;

/*This circuit template checks that c is the multiplication of a and b.*/  

template CustomCircuit () {  
    // signal inputs

    signal input a;
    signal input b;


    // signals from gates
    signal x;
    signal y;

    // final signal output
    signal output q;

    // component gates used to crrate custom circuit 
    component andGate = AND();
    component notGate = NOT();
    component orGate = OR();

    // circuit logic

    // for and gate 
    andGate.a <== a;
    andGate.b <== b;

    x <== andGate.out;

    // for not gate
    notGate.in <==b;

    y <== notGate.out;

    // for or gate
    orGate.a <== x;
    orGate.b <== y;
    
    q <== orGate.out;
    
}

template AND() {
    signal input a;
    signal input b;
    signal output out;

    out <== a*b;
}

template NOT() {
    signal input in;
    signal output out;

    out <== 1 + in - 2*in;
}

template OR() {
    signal input a;
    signal input b;
    signal output out;

    out <== a + b - a*b;
}
component main = CustomCircuit();
   
```
# Description of the circuit code
The AND, NOT, and OR gates each have three distinct templates. The logic of each gate is represented by these templates.

There are inputs a and b as well as an output q defined for the primary circuit template called CustomCircuit.

The respective templates are used to create the component gates AND, NOT, and OR.

To implement the necessary circuit logic, connections are made between input signals and the inputs of gates as well as between the outputs of gates and signals.

Using the specified AND, NOT, and OR gates, the output q of the custom circuit is calculated based on the inputs a and b.

You would need to instantiate this circuit template, connect it to other components of your circuit (if necessary), and define the inputs and outputs appropriately in order to use it in your Circom project. For instance, you may specify the input signals a and b before using the main component to compute the output q.
* Change the input of a = 0 and b = 1 in input.json to match the specifications by going there. 

# Commands to be given for deployment 
### Install
`npm i`

### Compile
`npx hardhat circom` 
This will generate the **out** file with circuit intermediaries and geneate the **MultiplierVerifier.sol** contract

### Prove and Deploy
`npx hardhat run scripts/deploy.ts`
This script does 4 things  
1. Deploys the MultiplierVerifier.sol contract
2. Generates a proof from circuit intermediaries with `generateProof()`
3. Generates calldata with `generateCallData()`
4. Calls `verifyProof()` on the verifier contract with calldata

With two commands you can compile a ZKP, generate a proof, deploy a verifier, and verify the proof ðŸŽ‰

## Configuration
### Directory Structure
**circuits**
```
â”œâ”€â”€ multiplier
â”‚   â”œâ”€â”€ circuit.circom
â”‚   â”œâ”€â”€ input.json
â”‚   â””â”€â”€ out
â”‚       â”œâ”€â”€ circuit.wasm
â”‚       â”œâ”€â”€ multiplier.r1cs
â”‚       â”œâ”€â”€ multiplier.vkey
â”‚       â””â”€â”€ multiplier.zkey
â”œâ”€â”€ new-circuit
â””â”€â”€ powersOfTau28_hez_final_12.ptau
```
Every new circuit has its own directory to call home. Each circuit directory contains the circom circuit and input to the circuit at the top level.
The compiled outputs, keys, and proofs will be stored in the automatically created **out** directory. The Polygon Hermez ceremony, which saves time by not requiring a new ceremony, is where the Powers of Tau file originates. 

**contracts**
```
contracts
â””â”€â”€ MultiplierVerifier.sol
```
Verifier contracts are autogenerated and prefixed by the circuit name, in this example **Multiplier**

## hardhat.config.ts
```
  circom: {
    // (optional) Base path for input files, defaults to `./circuits/`
    inputBasePath: "./circuits",
    // (required) The final ptau file, relative to inputBasePath, from a Phase 1 ceremony
    ptau: "powersOfTau28_hez_final_12.ptau",
    // (required) Each object in this array refers to a separate circuit
    circuits: JSON.parse(JSON.stringify(circuits))
  },
```
### circuits.config.json
For **autogenerated** purposes (see following part), circuits configuration is isolated from hardhat.config.ts.
```
[
  {
    "name": "multiplier",
    "protocol": "groth16",
    "circuit": "multiplier/circuit.circom",
    "input": "multiplier/input.json",
    "wasm": "multiplier/out/circuit.wasm",
    "zkey": "multiplier/out/multiplier.zkey",
    "vkey": "multiplier/out/multiplier.vkey",
    "r1cs": "multiplier/out/multiplier.r1cs",
    "beacon": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
]
```
# Author 
Jaya Singh
